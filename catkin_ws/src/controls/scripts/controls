#!/usr/bin/env python
from math import pi
from math import fabs
import numpy as np
import rospy
from geometry_msgs.msg import Wrench
from auv_msgs.msg import (
    SetVelocityAction, SetVelocityFeedback, SetVelocityResult,
    SetPositionAction, SetPositionFeedback,
    VisualServoAction, VisualServoFeedback, VisualServoResult)
import tf
from tf.transformations import euler_from_quaternion
from actionlib import SimpleActionServer
from std_msgs.msg import Bool

# flake8 wants these declared up here
pos_server = None
vel_server = None
vservo_server = None

depth_desired = 0.0
depth_estimated = 0.0
depth_vservo_no_target = 0.0
angles_desired = np.zeros(3)
angles_estimated = np.zeros(3)
proportional_error = np.zeros(4)
integral_error = np.zeros(4)

# Position control
target_frame_id = ''
pos_desired = np.zeros(2)
pos_integral_error = np.zeros(2)
pos_proportional_error = np.zeros(2)

# Absolute value
surge_speed = 0.0
sway_speed = 0.0

# Error tolerances
yaw_error_tol = 0.1
x_error_tol = 0.05
y_error_tol = 0.05
depth_error_tol = 0.05

server = None
listener = None
wrench_publisher = None
mission = False


def normalize_angle(angle, max_angle=pi):
    # Returns angle between -max_angle and max_angle
    angle = angle % (2 * pi)
    if angle > pi:
        angle -= 2 * pi
    return angle


def set_velocity_callback():
    global angles_desired, surge_speed, sway_speed, depth_desired, last_heading
    set_position_preempt()
    visual_servo_preempt()
    cmd = vel_server.accept_new_goal().cmd
    angles_desired[0] = cmd.roll
    angles_desired[1] = cmd.pitch
    angles_desired[2] = cmd.yaw
    surge_speed = cmd.surgeSpeed
    sway_speed = cmd.swaySpeed
    depth_desired = cmd.depth
    last_heading = cmd.yaw
    rospy.loginfo('Received New Goal: {}'.format(cmd))


def set_position_callback():
    global angles_desired, pos_desired, depth_desired, target_frame_id
    set_velocity_preempt()
    visual_servo_preempt()
    cmd = pos_server.accept_new_goal().cmd
    target_frame_id = cmd.target_frame_id
    angles_desired[0] = cmd.roll
    angles_desired[1] = cmd.pitch
    angles_desired[2] = cmd.yaw
    pos_desired[0] = cmd.xPos
    pos_desired[1] = cmd.yPos
    depth_desired = cmd.depth


def visual_servo_callback():
    global angles_desired, angles_estimated, target_frame_id, depth_estimated
    global depth_vservo_no_target
    set_velocity_preempt()
    set_position_preempt()
    cmd = vservo_server.accept_new_goal().cmd
    target_frame_id = cmd.target_frame_id
    angles_desired[0] = cmd.roll
    angles_desired[1] = cmd.pitch
    angles_desired[2] = cmd.yaw
    depth_vservo_no_target = depth_estimated


def set_velocity_preempt():
    if vel_server.is_active():
        vel_server.set_preempted()


def set_position_preempt():
    if pos_server.is_active():
        pos_server.set_preempted()


def visual_servo_preempt():
    if vservo_server.is_active():
        vservo_server.set_preempted()


def get_transform(origin_frame, target_frame):
    global listener
    if not listener:
        listener = tf.TransformListener()
    (trans, rot) = listener.lookupTransform(
        # FROM
        origin_frame,
        # TO
        target_frame,
        # NOW
        rospy.Time())
    return (trans, rot)


def mission_cb(msg):
    global mission
    mission = msg.data


def ros_init():
    global wrench_publisher, listener, pos_server, vel_server, vservo_server
    global mission_sub

    rospy.init_node('controls')

    mission_sub = rospy.Subscriber('mission', Bool, mission_cb)

    listener = tf.TransformListener()

    vel_server = SimpleActionServer('controls_velocity',
                                    SetVelocityAction,
                                    auto_start=False)
    vel_server.register_goal_callback(set_velocity_callback)
    vel_server.register_preempt_callback(set_velocity_preempt)
    vel_server.start()

    pos_server = SimpleActionServer('controls_position',
                                    SetPositionAction,
                                    auto_start=False)
    pos_server.register_goal_callback(set_position_callback)
    pos_server.register_preempt_callback(set_position_preempt)
    pos_server.start()

    vservo_server = SimpleActionServer('controls_vservo',
                                       VisualServoAction,
                                       auto_start=False)
    vservo_server.register_goal_callback(visual_servo_callback)
    vservo_server.register_preempt_callback(visual_servo_preempt)
    vservo_server.start()

    wrench_publisher = rospy.Publisher('controls/wrench',
                                       Wrench,
                                       queue_size=100)
    # Maybe we can use rospy.wait_for_message instead of this?
    t = rospy.Time.now() + rospy.Duration.from_sec(1)

    while rospy.Time.now() < t:
        try:
            get_transform("initial_horizon", "robot")
            break
        except (tf.LookupException, tf.ConnectivityException,
                tf.ExtrapolationException):
            pass


def loop(event):
    global pos_proportional_error, pos_integral_error, proportional_error
    global integral_error
    global angles_estimated, depth_estimated, depth_desired, surge_speed
    global depth_vservo_no_target

    if not mission:
        rospy.loginfo("No Mission")
        return
    if not (pos_server.is_active() or
            vel_server.is_active() or
            vservo_server.is_active()):
        rospy.logwarn("No actionlib server is active")
        return

    try:
        # Velocity control is open-loop
        fx = surge_coeff * surge_speed
        fy = sway_coeff * sway_speed

        # TODO: Use one get_transform
        (trans, rot) = get_transform("/initial_horizon", "/robot")
        # Use static frame, RPY
        angles_estimated = list(euler_from_quaternion(rot, axes='sxyz'))
        (trans, rot) = get_transform('/floating_horizon', '/robot')
        depth_estimated = trans[2]
        # For Testing: angles_estimated[2] += 0.05

        if pos_server.is_active():
            (x_err, y_err, _), quaternion = get_transform(target_frame_id,
                                                          '/horizon')
            yaw_err = euler_from_quaternion(quaternion)[2]
            pos_proportional_error_prev = pos_proportional_error
            pos_proportional_error = pos_desired - np.array([x_err, y_err])
            pos_integral_error += pos_proportional_error * dt
            pos_derivative_error = (pos_proportional_error -
                                    pos_proportional_error_prev) / dt
            fx, fy = (pos_integral_error * pos_integral_gains +
                      pos_proportional_error * pos_proportional_gains +
                      pos_derivative_error * pos_derivative_gains)
            angles_estimated[2] = yaw_err
        elif vservo_server.is_active():
            rospy.loginfo("Visual Servo Server Active")
            (x_err, y_err, z_err), quaternion = get_transform('/robot',
                                                              target_frame_id)
            pos_proportional_error_prev = pos_proportional_error
            pos_proportional_error = np.array([x_err, y_err])
            pos_integral_error += pos_proportional_error * dt
            pos_derivative_error = (pos_proportional_error -
                                    pos_proportional_error_prev) / dt
            fx, fy = (pos_integral_error * pos_integral_gains +
                      pos_proportional_error * pos_proportional_gains +
                      pos_derivative_error * pos_derivative_gains)

            if z_err == 0:  # keep latest depth before vservo lost target
                depth_desired = depth_vservo_no_target
                rospy.logwarn("Not seeing target, setting depth_desired to depth_vservo_no_target: %f", depth_vservo_no_target)
            else:
                depth_desired = depth_estimated + z_err
                depth_vservo_no_target = depth_desired

        proportional_error_prev = proportional_error.copy()
        proportional_error[0:3] = angles_desired - angles_estimated
        proportional_error[3] = depth_desired - depth_estimated
        integral_error += proportional_error * dt
        derivative_error = (proportional_error - proportional_error_prev) / dt

        rospy.logdebug('angles_estimated: {}'.format(angles_estimated))
        rospy.logdebug('angles_desired: {}'.format(angles_desired))
        rospy.logdebug('depth_estimated: {}'.format(depth_estimated))
        rospy.logdebug('depth_desired: {}'.format(depth_desired))

        # Correct yaw angle error for wrap around. The other angles are
        # not corrected only small roll and pitch are supported.
        proportional_error[2] = normalize_angle(proportional_error[2])
        derivative_error[2] = normalize_angle(derivative_error[2])

        # Send feedback on yaw error
        if vel_server.is_active():
            feedback = SetVelocityFeedback()
            feedback.yaw_error = proportional_error[2]
            feedback.depth_error = proportional_error[3]
            vel_server.publish_feedback(feedback)
            if (fabs(feedback.yaw_error) < yaw_error_tol and
               fabs(feedback.depth_error) < depth_error_tol):
                # Close enough, tell client we're done turning
                result = SetVelocityResult()
                result.success = True
                vel_server.set_succeeded(result)
        elif pos_server.is_active():
            feedback = SetPositionFeedback()
            feedback.yaw_error = proportional_error[2]
            feedback.depth_error = proportional_error[3]
            feedback.x_error = pos_proportional_error[0]
            feedback.y_error = pos_proportional_error[1]
            pos_server.publish_feedback(feedback)
        elif vservo_server.is_active():
            feedback = VisualServoFeedback()
            feedback.x_error = pos_proportional_error[0]
            feedback.y_error = pos_proportional_error[1]
            feedback.depth_error = proportional_error[3]
            vservo_server.publish_feedback(feedback)

            # Must be greater than exact zero to make sure
            # we don't return success when object is lost:
            if (0 < fabs(feedback.y_error) < 0.1 and
               0 < fabs(feedback.depth_error) < 0.1):
                result = VisualServoResult()
                result.success = True
                vservo_server.set_succeeded(result)

        output = (integral_error * integral_gains +
                  proportional_error * proportional_gains +
                  derivative_error * derivative_gains)

        rospy.logdebug("Proportional Error: {}".format(proportional_error))
        rospy.logdebug("Integral Error {}".format(integral_error))
        rospy.logdebug("Derivative Error {}".format(derivative_error))

        # Need to transform the desired force into the body frame
        # for thrustmapper.
        # Use the following lines to add force correction based on angle erros:
        # matrix = euler_matrix(angles_estimated[0], angles_estimated[1], 0).T
        # force = np.dot(matrix, [fx, fy, output[3], 1])[:3]
        # Use the line below to ignore the effects of angle errors
        # on translation (to avoid unexpected sway):
        force = [fx, fy, output[3]]

        # Remove negative z forces to account for the robot's buoyancy
        if force[2] < 0:
            force[2] = 0

        wrench_msg = Wrench()
        wrench_msg.force.x = force[0]
        wrench_msg.force.y = force[1]
        wrench_msg.force.z = force[2]
        wrench_msg.torque.x = output[0]
        wrench_msg.torque.y = output[1]
        wrench_msg.torque.z = output[2]
        wrench_publisher.publish(wrench_msg)
    except tf.Exception as e:
        rospy.logerr(e)


if __name__ == '__main__':
    global integral_gains, proportional_gains, derivative_gains, dt
    ros_init()
    integral_gains = np.array([
        rospy.get_param("~ki_roll"),
        rospy.get_param("~ki_pitch"),
        rospy.get_param("~ki_yaw"),
        rospy.get_param("~ki_depth")])
    proportional_gains = np.array([
        rospy.get_param("~kp_roll"),
        rospy.get_param("~kp_pitch"),
        rospy.get_param("~kp_yaw"),
        rospy.get_param("~kp_depth")])
    derivative_gains = np.array([
        rospy.get_param("~kd_roll"),
        rospy.get_param("~kd_pitch"),
        rospy.get_param("~kd_yaw"),
        rospy.get_param("~kd_depth")])
    pos_integral_gains = np.array([
        rospy.get_param('~ki_xPos'),
        rospy.get_param('~ki_yPos')])
    pos_proportional_gains = np.array([
        rospy.get_param('~kp_xPos'),
        rospy.get_param('~kp_yPos')])
    pos_derivative_gains = np.array([
        rospy.get_param('~kd_xPos'),
        rospy.get_param('~kd_yPos')])

    surge_coeff = rospy.get_param("~surge_coeff")
    sway_coeff = rospy.get_param("~sway_coeff")

    yaw_error_tol = rospy.get_param("~yaw_error_tol")
    x_error_tol = rospy.get_param("~x_error_tol")
    y_error_tol = rospy.get_param("~y_error_tol")
    depth_error_tol = rospy.get_param("~depth_error_tol")

    dt = 0.1
    timer = rospy.Timer(rospy.Duration(dt), loop)
    rospy.on_shutdown(timer.shutdown)
    rospy.spin()
